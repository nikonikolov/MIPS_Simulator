<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>My Project: Architecture II 2015, Coursework 1</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Architecture II 2015, Coursework 1 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Goals of this coursework </h2>
<p>There are three central aims of this coursework:</p>
<ul>
<li>Solidify your understanding of how an instruction processor actually functions. The overall functionality of how a processor works is relatively easy to grasp, but there is lots of interesting detail which gives you a lot of insight (both into CPUs, but also into software and digital design).</li>
<li>Understand the importance of having good specifications, in terms of functionality, APIs, and requirements. This is fundamental to CPU design and implementation, but is also true in the wider world (again) of software and digital design.</li>
<li>Develop your skills in coding from scratch. There is not much scaffolding here, I am genuinely asking you to create your own CPU simulator from scratch.</li>
</ul>
<h2>Coursework Deliverables </h2>
<p>There are two C/C++ components to this coursework:</p>
<ol type="1">
<li>Create a MIPS software simulator</li>
<li>Develop a test suite for your MIPS simulator</li>
</ol>
<p>The API for the simulator is given as a bare C header file, defining the functions and data-types involved, along with a functional specification of what a simulator should do. The API acts as the interface between your simulator and your test-suite, and indeed <em>any</em> simulator and test-suite.</p>
<p>Your submitted code will consist of a zip file, containing the original directory structure and files, as well as the files that you have contributed. The two key things you will be adding are:</p>
<ul>
<li><code>src/[your_login]/mips_cpu.c</code> or <code>mips_cpu.cpp</code></li>
<li><code>src/[your_login]/test_mips.c</code> or <code>test_mips.cpp</code></li>
</ul>
<p>The first part is the implementation of a mips simulator, and is essentially a library that implements the api found in include/mips_cpu.h. You can use C or C++, either is fine. If you want to split into multiple files, then feel free to do so - anything which matches the pattern <code>src/[your_login]/mips_cpu_*.c</code> or <code>src/[your_login]/mips_cpu_*.cpp</code> will also get compiled into your library.</p>
<p>The second part is the test suite which will drive your simulator and make it do things. This is a C or C++ program (so it will have a main function), and should be either <code>src/[your_login]/test_mips.c</code> or <code>src/[your_login]/test_mips.cpp</code>. Again, if you want to split into multiple files, anything that matches the pattern <code>src/[your_login]/test_mips_*.c</code> or <code>src/[your_login]/test_mips_*.cpp</code> will get compiled into your program.</p>
<p>You can also add your own private header files (generally a good idea), which should be part of the submitted zip file, but they don't need to follow any specific pattern. However, they should be completely located within the <code>src/[your_login]</code> directory or a sub-directory of it. Note that your simulator and your test suite are two different components, so do not rely on the specific behaviour of <em>your</em> simulator, it should work with any simulator that follows the API.</p>
<p>The directory structure should look like: </p><pre class="fragment">.
+-readme.md  # This document
|
+-include
| |
| +-mips.h
| +-mips_*.h  # Other mips headers
|
+-src
| |
| +-shared
| | | 
| | +-mips_mem_ram.cpp
| | +-mips_test_framework.cpp
| |
| +-[your_login] # This is your private folder
|   |
|   +-mips_cpu.c or mips_cpu.cpp
|   +-mips_cpu_*.c or mips_cpu_*.cpp (if you want them)
|   |
|   +-test_mips.c or test_mips.cpp
|   +-test_mips_*.c or test_mips_*.cpp (if you want them)
|   |
|   +-(anything else you want, e.g. headers, docs)
|
+-doc
|
+-fragments # Some very simple examples of C, assembly, and binary code
|
+-(anything else you want, but it won't be available in the environment)
</pre><p>Your submitted code will need to work within the compilation environment specified later on (another part of the specification). The file names and structure <em>must</em> match those mandated here.</p>
<p>If you're wondering why I'm being so prescriptive about this, it is because I've already done all your marking, which required me to know what your submission looks like and what I can do with it. The given structure allows me to know exactly what your code needs in order to compile (I need to tell the compiler which source files to link together), and when I want to move implementations around I need to know what is important (so stuff in src/&lt;your_login&gt;.</p>
<h2>Assessment criteria </h2>
<p>This is an exercise in both implementing specifications, and in testing specifications, so the assessment is weighted as follows:</p>
<ul>
<li>20% Compilation and robustness: How much (manual) work was needed to make the submission compile in the target environment and run without crashing? The expectation is that everyone can get full marks here.</li>
<li>50% Functionality: What proportion of the CPU simulator's functions operate correctly? It is unlikely that many submissions will get all instructions working perfectly, but there is a core subset that everyone will be able to get fully working, a larger set that most people will be able to get partially working, and some instructions that are really quite difficult to get right and many people won't attempt. Some hints on that will appear later.</li>
<li>30% Testing: What proportion of the CPU simulator is exercised and tested by the submitted test suite? So <em>if</em> an instruction is implemented, is it a) exercised, and b) is the result checked. You can still get a decent mark here even if you have a small number of instructions implemented, as long as they are tested well.</li>
<li>(10%) Bug reports: This specification will not be perfect, and I welcome bug reports. Things like spelling mistakes are welcome, but not especially valuable. What is important are points of genuine ambiguity, or errors of implementation in the code spec. Bug reports should identify both the problem, and how to reproduce it, and particularly welcome are bug reports with suggested fixes. Note that "I don't know
  what to do" or "my program crashes" or "this is too hard" are not bugs, they need to be errors in the specification.</li>
</ul>
<p>Except for the marks for compilation (where everyone should really get full marks, but is down to me assessing how much manual work I needed to put in) and bug reports (which are subjective and more rare) the assessment is entirely quantitative and metric based.</p>
<p>There are two submission deadlines, one soft, one hard:</p>
<ul>
<li>Friday 23th October 22:00: deadline for formative (ungraded) assessment. If you submit a version by this deadline, it will be put through a subset of the assessment. The results (but not a grade), will be returned on Monday 26th. Submission is not required, but is obviously encouraged.</li>
<li>Friday 30th October 22:00: deadline for summative (graded) assessment. Whether or not you submitted for the previous deadline, everyone must submit for this deadline. This will be the part which results in the grade for this coursework.</li>
</ul>
<p>The idea of the first deadline is for you to test whatever you have working. You might only have one or two instructions working at that point, which is fine. Submit that, and it will give you some confidence that the way you are doing things is correct.</p>
<h2>Compilation Environment </h2>
<p>For most people it is sufficient to say: the target compilation is plain C or C++, and the target environment is the C and/or C++ standard library. It is easy to stay within platform independent APIs, as no platform-specific interaction with the environment is needed during execution. So it should work happily on both linux and windows.</p>
<p>The actual target environment is the lab Ubuntu environment, and the version of gcc/g++ installed there. You can develop in Windows, MacOS, or another linux, but you need to make sure it works in that environment.</p>
<p>During compilation, the include directories will be set up to have both the <code>include</code> directory (containing <code>mips.h</code>) and the <code>src/[your_login]</code> directory on the include path. The directory structure during compilation will be the same as that required during submission, so the relative location of things will stay the same.</p>
<p>When running your test suite, the executable will be launched with its working directory as <code>src/[your_login]</code>, so if you wish to read files you can place them there (or in sub-directories).</p>
<p>When your CPU simulator is executing, you can make no assumptions about the working directory, or the presence or absence of other files.</p>
<h2>Managing expectations </h2>
<p>You may think that it is always possible to get 90-100% in coursework if you just work hard enough. That is not true here, and will usually not be true in your future courseworks. The grade distribution for this coursework should be roughly the same as exam grade distributions, and certainly was last year. So 70% is a good mark, 80%+ is a great mark, and anything above 60% shows that you're doing ok.</p>
<p>Some students will have more programming experience, and so will find this exercise easier, and may well end up with a higher grade. That's life I'm afraid, just like some people turned up last year knowing more of the maths curriculum. This mark goes into Computing Lab, which is intended to encourage and recognise ability in the practical application of programming and computing concepts. For those students who are less experienced in programming this kind of exercise is much more valuable, and they will get more out of it. But everyone, no matter their programming ability, should find it helps clarify their current understanding of instruction processors, and supports their learning through the rest of this module.</p>
<h2>Guidance on instructions </h2>
<p>We are going to look at the MIPS-1 (or MIPS-I) instruction set, in big endian mode. There are 47 instructions eligible for implementation, as certain instructions such as SYSCALL are too complex to handle here. The following table gives the mnemonics, the description, and a rough guide to how complex they are. Note that the complexity is based on both how easy it is to implement the base functionality, but also how easy it is to deal with, and try to test, corner cases.</p>
<table class="doxtable">
<tr>
<th>Code </th><th>Meaning </th><th>Complexity  </th></tr>
<tr>
<td>ADD </td><td>Add (with overflow) </td><td>2 XX </td></tr>
<tr>
<td>ADDI </td><td>Add immediate (with overflow) </td><td>2 XX </td></tr>
<tr>
<td>ADDIU </td><td>Add immediate unsigned (no overflow) </td><td>2 XX </td></tr>
<tr>
<td>ADDU </td><td>Add unsigned (no overflow) </td><td>1 X </td></tr>
<tr>
<td>AND </td><td>Bitwise and </td><td>1 X </td></tr>
<tr>
<td>ANDI </td><td>Bitwise and immediate </td><td>2 XX </td></tr>
<tr>
<td>BEQ </td><td>Branch on equal </td><td>3 XXX </td></tr>
<tr>
<td>BGEZ </td><td>Branch on greater than or equal to zero </td><td>3 XXX </td></tr>
<tr>
<td>BGEZAL</td><td>Branch on non-negative (&gt;=0) and link </td><td>4 XXXX </td></tr>
<tr>
<td>BGTZ </td><td>Branch on greater than zero </td><td>3 XXX </td></tr>
<tr>
<td>BLEZ </td><td>Branch on less than or equal to zero </td><td>3 XXX </td></tr>
<tr>
<td>BLTZ </td><td>Branch on less than zero </td><td>3 XXX </td></tr>
<tr>
<td>BLTZAL</td><td>Branch on less than zero and link </td><td>4 XXXX </td></tr>
<tr>
<td>BNE </td><td>Branch on not equal </td><td>3 XXX </td></tr>
<tr>
<td>DIV </td><td>Divide </td><td>4 XXXX </td></tr>
<tr>
<td>DIVU </td><td>Divide unsigned </td><td>3 XXXX </td></tr>
<tr>
<td>J </td><td>Jump </td><td>3 XXX </td></tr>
<tr>
<td>JALR </td><td>Jump and link register </td><td>4 XXXX </td></tr>
<tr>
<td>JAL </td><td>Jump and link </td><td>4 XXXX </td></tr>
<tr>
<td>JR </td><td>Jump register </td><td>3 XXX </td></tr>
<tr>
<td>LB </td><td>Load byte </td><td>3 XXX </td></tr>
<tr>
<td>LBU </td><td>Load byte unsigned </td><td>3 XXX </td></tr>
<tr>
<td>LH </td><td>Load half-word </td><td>3 XXX </td></tr>
<tr>
<td>LHU </td><td>Load half-word unsigned </td><td>3 XXX </td></tr>
<tr>
<td>LUI </td><td>Load upper immediate </td><td>2 XX </td></tr>
<tr>
<td>LW </td><td>Load word </td><td>2 XX </td></tr>
<tr>
<td>LWL </td><td>Load word left </td><td>5 XXXXX </td></tr>
<tr>
<td>LWR </td><td>Load word right </td><td>5 XXXXX </td></tr>
<tr>
<td>MFHI </td><td>Move from HI </td><td>3 XXXX </td></tr>
<tr>
<td>MFLO </td><td>Move from LO </td><td>3 XXXX </td></tr>
<tr>
<td>MTHI </td><td>Move to HI </td><td>3 XXXX </td></tr>
<tr>
<td>MTLO </td><td>Move to LO </td><td>3 XXXX </td></tr>
<tr>
<td>MULT </td><td>Multiply </td><td>4 XXXX </td></tr>
<tr>
<td>MULTU </td><td>Multiply unsigned </td><td>3 XXXX </td></tr>
<tr>
<td>OR </td><td>Bitwise or </td><td>1 X </td></tr>
<tr>
<td>ORI </td><td>Bitwise or immediate </td><td>2 XX </td></tr>
<tr>
<td>SB </td><td>Store byte </td><td>3 XXX </td></tr>
<tr>
<td>SH </td><td>Store half-word </td><td>3 XXX </td></tr>
<tr>
<td>SLL </td><td>Shift left logical </td><td>2 XX </td></tr>
<tr>
<td>SLLV </td><td>Shift left logical variable </td><td>3 XX </td></tr>
<tr>
<td>SLT </td><td>Set on less than (signed) </td><td>2 XX </td></tr>
<tr>
<td>SLTI </td><td>Set on less than immediate (signed) </td><td>3 XXX </td></tr>
<tr>
<td>SLTIU </td><td>Set on less than immediate unsigned </td><td>3 XXX </td></tr>
<tr>
<td>SLTU </td><td>Set on less than unsigned </td><td>1 X </td></tr>
<tr>
<td>SRA </td><td>Shift right arithmetic </td><td>2 XX </td></tr>
<tr>
<td>SRAV </td><td>Shift right arithmetic </td><td>2 XX </td></tr>
<tr>
<td>SRL </td><td>Shift right logical </td><td>2 XX </td></tr>
<tr>
<td>SRLV </td><td>Shift right logical variable </td><td>2 XX </td></tr>
<tr>
<td>SUB </td><td>Subtract </td><td>2 XX </td></tr>
<tr>
<td>SUBU </td><td>Subtract unsigned </td><td>1 X </td></tr>
<tr>
<td>SW </td><td>Store word </td><td>2 XX </td></tr>
<tr>
<td>XOR </td><td>Bitwise exclusive or </td><td>1 X </td></tr>
<tr>
<td>XORI </td><td>Bitwise exclusive or immediate </td><td>2 XX </td></tr>
</table>
<p>This is a not-quite an exhaustive list of MIPS-1 instructions. Any instruction not covered in this list will not be tested as part of the assessment, and any implementation defined behaviour is fine (return an error, or actually implement the instruction).</p>
<p>There are many instructions, but there is a lot of commonality between some instructions. Think about the underlying digital data-path in a real processor, and use that to identify where there are similarities.</p>
<p>You may get to the point where things start getting very boring, and you seem to be doing the same thing over and over, possibly by copying and pasting. This is generally an indication that you are missing an opportunity to abstract or automate. For example, how different are "and", "or", and "xor"? What is the shared functionality between "lb", "lw", and "lh"? You may want to re-factor your code every once in a while as you work out better ways of testing them - the purpose of your test-bench is to give you the confidence to do that.</p>
<p>As you move through the instructions you should find that you have to think carefully about the first instruction of each type, deciding how to implement and test it. The next of the same type should be much quicker, then the next almost mechanical, and you'll probably find two-thirds of the instructions are done in a minute each. However, you should still expect this to take a substantial amount of time, particularly if you plan to do all instructions.</p>
<p>I would expect most people to be able to implement and test all the 1s and 2s fairly easily. Implementing the 3s is not so difficult, but testing them can be more complex. The 4s are doable, but have some complexity in implementation and testing. Implementing the 5s correctly is really quite challenging.</p>
<h2>Getting Started </h2>
<h3>Read this document</h3>
<p>You have got to this point already. If you skipped to here, go back and read the entire thing again.</p>
<h3>Get the source code</h3>
<p>You can get the source code either by:</p>
<ol type="1">
<li>Downloading the zip file (see the link on the right hand side), which gives you a snapshot of the files in the repository.</li>
<li>Cloning the source code to your local directory, keeping the git information intact. You don't need a github account to do this, and your repository will be private.</li>
<li>Fork the code into your own repository. This assumes that you have your own account, and presumably the ability to keep that repository private. See the <a href="https://education.github.com/pack">Student Pack</a> if you're interested in that direction.</li>
</ol>
<p>While it is not required, I would highly recommend that you try option 2 (I will use this route in class). It is good to get some experience of how source control works, and acting as a consumer is a good way of understanding what is going on. There are a number of GUI tools available which make things easier:</p>
<ul>
<li>The github GUI is available for <a href="https://windows.github.com/">Windows</a>, <a href="https://mac.github.com/">Mac</a>.</li>
<li>There are third party GUI tools like <a href="https://code.google.com/p/tortoisegit/">TortoiseGIT</a></li>
<li>There is a default GUI called <a href="https://www.kernel.org/pub/software/scm/git/docs/git-gui.html">git gui</a> from the main git people, that should be cross platform.</li>
<li>Or you can just use the command line. If you are only using git to get and update the code, then "git clone" and "git pull" are easy to use.</li>
</ul>
<p>The submission itself is through blackboard as a zip, so there is no requirement to use git. Even if I update the repository, you can still just download the zip again and copy your current work in - it is deliberately designed so that copying your <code>src/&lt;login&gt;</code> directory into the updated source code will work.</p>
<h3>Read the source code</h3>
<p>The source code is part of the specification, and is heavily documented (it is much more important to document APIs than it is to document implementation). Suggested reading order is:</p>
<ul>
<li><code>include/mips.h</code></li>
<li><code>include/mips_mem.h</code></li>
<li><code>include/mips_cpu.h</code></li>
<li><code>include/mips_test.h</code></li>
</ul>
<p><em>Optional</em>: The comments follow the format for a well-known tool called <a href="http://www.stack.nl/~dimitri/doxygen/">doxygen</a>. If you apply doxygen to the file <code>doc/mips.doxygen</code>, then it will generate some nice html formatted API documentation for you.</p>
<h3>Check you understand MIPS</h3>
<p>The ISA we are using is a subset of the MIPS-1 (or MIPS-I) instruction set in big endian mode. There is a lot of discussion of MIPS in the course text book, and the MIPS specification itself is available online, for example: <a href="http://math-atlas.sourceforge.net/devel/assembly/mips-iv.pdf">http://math-atlas.sourceforge.net/devel/assembly/mips-iv.pdf</a> There are multiple revisions or extensions of the instruction set, so remember that we are only considering MIPS-1.</p>
<p>I think this is quite a nice break-down of the instructions, but be careful about the details: <a href="http://www.mrc.uidaho.edu/mrc/people/jff/digital/MIPSir.html">http://www.mrc.uidaho.edu/mrc/people/jff/digital/MIPSir.html</a></p>
<p>Another summarised version is the <a href="https://www.lri.fr/~de/MIPS.pdf">QuickReference</a>. This one is particularly useful as it highlights the commonalities between instructions, which both makes implementation clearer, and helps to visualise how the hardware works.</p>
<h2>Some Questions I've recieved </h2>
<p>Note to 2015 students: I ran almost the same coursework last year, so these are some questions from then. And as you would hope and expect, I still have all of their submissions in a readily accessible form should I choose to diff them against this years submissions.</p>
<h3>What is the idea of splitting up the tests?</h3>
<blockquote class="doxtable">
<p>I am confused about what we are expected to write in test_mips.cpp. In my experience, a test script executes the functions of the system it is testing and checks whether the output/state of the system was expected or not. My instinct would be to have a header file with a C++ function for each MIPS instruction defining the operations of the instruction, then in test_mips I would test those functions by calling them with various values to check they work properly.</p>
<p>However, from reading the comments you left in the test_mips file you included, it seems like you want us to define the functionality of the different MIPS instructions in this file, which doesn't make it a test script to me.</p>
<p>Can you help clear up my confusion please? </p>
</blockquote>
<p>The suggested approach, of decomposing the functionality into multiple functions for each instruction then testing them individually, makes perfect sense for the developer of a particular MIPS implementation. I might choose to do that during initial development of the CPU implementation, to check the smallest components work. Equally, if I were building a hardware cpu I would create test-benches for the ALU, where there were different sets of waveforms which would cause it to perform an add, a subtract, etc.</p>
<p>The problem is that even though the individual instruction operations would be tested, we would not know whether they are actually decoded correctly, whether interactions with memory work correctly, whether it depends on a particular kind of memory, whether each operation behaves correctly if it appears after a jump, and so on.</p>
<p>So you are correct that the test_mips file should define the functionality, but <em>only</em> the functionality, it should say nothing about the implementation of that functionality. If you know the initial state of a MIPS, plus the memory it is attached to, you should be able to predict precisely what the effect of the next instruction executed should be. You could do that prediction as a human, by reading the ISA spec and thinking, or with the help of code, but it needs to be completely seperate from the implementation being tested.</p>
<p>I could have mandated that you must implement one function for each of the instructions, and put it in a header, but then I would constrain any other implementer. Some people may not want one function per operation, and there are good reasons for doing that. Equally, it would now be impossible to apply the test suite to a digital MIPS in a logic simulator, as there is no equivalent way to implement those functions in a digital implementation.</p>
<h3>Why is the pointer to mips_mem_read 8 bit?</h3>
<blockquote class="doxtable">
<p>We need to read and write 32-bit values, but the argument to mips_mem_read is an 8-bit pointer. Do we need to cast it? </p>
</blockquote>
<p>Yes, you need to cast to the type you want to read or write.</p>
<p>The minimum addressable unit for the memory is 8-bits, but the block size (minimum transfer) for MIPS is 32-bits. So you'll need to cast to and from the types you want to read and write: </p><pre class="fragment">uint32_t val;
mips_error err=mips_mem_read(mem, 12, 4, (uint8_t*)&amp;val);
val=val+1;
if(!err)
    err=mips_mem_write(mem, 12, 4, (uint8_t*)&amp;val);
</pre><p>This should (I haven't compiled it) increment the 32-bit value stored at byte address 12.</p>
<p>But... watch out for endianess!</p>
<p>I've put other examples in the documentation for mips_mem_write.</p>
<h3>How do I implement mips_mem_provider?</h3>
<blockquote class="doxtable">
<p>How to define mips_mem_provider? I think that I need to set up an array of 8 bit integers, and have a mips_cpu_h pointing to my CPU in operation. My problem is that I am unsure how to choose an appropriate initial size for the array given that the create_ram function decides how large the array will be. Would I need to include the block size? </p>
</blockquote>
<p>An implementation of mips_mem_provider is defined for you in the <code>src/shared_mips_mem_ram.cpp</code> file, so you don't need to implement that, just add it into the compilation (e.g. add as an existing source file into eclipse).</p>
<p>As for memory size, you should create a RAM that is big enough both to contain the instructions you want to test, and any data that you want to be able to read/write (e.g. by LW or SW) during those tests.</p>
<h3>What is the block size?</h3>
<blockquote class="doxtable">
<p>What is the purpose of block size? As far as I can workout from the comments in the code the block size is the smallest transfer one is able to make, why does the limitation exist and is there a reason we should pick a certain size? </p>
</blockquote>
<p>The block size is equivalent to the number of bits in the address bus. I've updated the documentation on mips_mem_create_ram to explain this better.</p>
<h3>What exactly goes on inside mips_cpu_step?</h3>
<blockquote class="doxtable">
<p>mips_error mips_cpu_step(mips_cpu_h state). Inside this function are we looking to extract 32-bits from memory at a time, determine whether it is an RIJ type, then pass on the appropriate segments of the 32 bit words to a function that completes the operation, then continue repeating the process until there is no longer anything left in memory? </p>
</blockquote>
<p>Yes, for everything up to "continue repeating the process". mips_cpu_step should fetch, decode, and execute just one instruction, update its state, then return back to the caller.</p>
<p>If the caller wants to execute multiple instructions, they must call mips_cpu_step once for each instruction.</p>
<h3>How is <code>mips_cpu_set_debug_level</code> supposed to be used?</h3>
<p>It is really down to you - it can do nothing if you prefer. I've updated the documentation for the function to give a better idea why it might be useful.</p>
<h2>What is the point of <code>mips_cpu_get_pc</code>?</h2>
<blockquote class="doxtable">
<p>Why is the mips_cpu_get_pc function necessary, can't you just get the value of the pc by doing state-&gt;pc, as you did in the skeleton file? </p>
</blockquote>
<p>You control the internals of the cpu state, so on the <code>mips_cpu.c</code> side, you can totally reach into <code>state-&gt;pc</code> and read it out. Or you can use <code>mips_cpu_get_pc</code>. Either is fine, because you are on the implementation side of the API.</p>
<p>However, on the <code>mips_test.cpp</code> side you are not allowed to know how or where the pc is stored, so <code>mips_cpu_get_pc</code> exists in order to allow the pc to be read from that side. I have already written the code that will test your CPU, and there is no way I could know whether you will do: </p><pre class="fragment">struct mips_cpu_impl{
  uint32_t pc;
  uint32_t regs[32];
};
</pre><p>or </p><pre class="fragment">struct mips_cpu_impl{
  uint32_t theseAreMyRegs[32];
  uint32_t thisIsMyPC;
};
</pre><p>or something else.</p>
<p>But I do know that I can call <code>mips_cpu_get_pc</code>, and no matter how or where you stored it I can find out what the current PC is. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Oct 17 2015 20:28:22 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
